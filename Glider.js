/*
 * @name Glider.js
 *
 * @fileOverview
 *
 * Glider.js provides lazy evaluation implementation of the
 * [Collection Pipeline](https://martinfowler.com/articles/collection-pipeline/) pattern for ServiceNow
 *
 * It's code style is heavily inspired by [Lazy.js](http://danieltao.com/lazy.js/).  Multiple variations
 * of this library were tested against one another in terms of performance and flexibility.  The Lazy.js
 * inspired variation outperformed the others by far and became the basis of the library.
 *
 * Understanding the Code
 * -------------------------
 *
 * At the heart of Glider.js is the {@link Sequence} object (what can I say, Daniel nailed the name).
 * You create a Collection Sequence by passing a Collection to the {@link Glider} function, which can
 * accept an Array, GlideRecord, or table + encoded query string.  You can then chain sequences
 * together by calling Pipeline Functions on the Sequence object or you can terminate the sequence
 * using a Terminal Function.
 *
 * **Collection Sequences** are source sequences such as an Array or GlideRecord which contain the
 * original elements.
 *
 * **Pipeline Functions** are functions of a sequence that return a Pipeline Sequence and allow
 * chaining.
 *
 * **Terminal Functions** are functions of a sequence that iterate the source collection,
 * processing the values
 *
 * Why Prototype Inheritance
 * --------------------------
 *
 * Prototype inheritance allows overriding Pipeline and Terminal functions depending on the
 * type of sequence returned.  For example, a ChunkSequence overrides the value function.
 *
 * This makes it easier to extend functionality and maintain the library.  Additionally,
 * since Javascript is prototype based, this helps Glider perform better than similar
 * libraries under most circumstances.
 *
 */
var Glider = (function() {
  /*
   * The Sequence object provides a common API for a collection of items. In this sense,
   * each transformation step (such as map or forEach) is itself a sequence of it's parent's
   * transformed values.
   *
   * This parent / child relationship is expressed by inheriting classes via the Iterator
   * pattern.  Inheriting classes implement the **next** and **current** functions.
   *
   * Collection Sequence
   * ------------------------
   * **next:** Should move an internal pointer to the next item in the collection
   * **current:** Should return the value at the current internal pointer position
   *
   * Pipeline Sequence
   * ------------------------
   * **next:** Should call the parent Sequence's next as often as needed to generate the next item
   * in its own sequence
   * **current:** Should return the item generated by the previous next call
   *
   * Terminal Function
   * ------------------------
   * Iterates the Sequence's parent's **next** until the Sequence is terminated.  Usually returns
   * an array or value.  You can think of this function as *pulling* the Collection Sequence values
   * through the transformation chain.
   *
   * These concepts create an easily replicable pattern of chainable Sequences which look like:
   *
   * Collection Sequence => Pipeline Sequences (0 or more) => Terminal Function
   *
   * @constructor
   */
  function Sequence() {}

  /*
   * Terminal Function that passes each element of the Sequence to the callback function.
   * @param {Sequence~forEachCallback} callback - function to call on each element in the sequence
   * @returns {undefined} No return value
   *
   * @callback Sequence~forEachCallback
   * @param {*} currentValue - Value of the current element being processed in the sequence
   * @returns {undefined} Return value for this callback is ignored
   */
  Sequence.prototype.forEach = function(callback) {
    var el;

    while (this.next()) {
      el = this.current();
      callback(el);
    }
  };

  /*
   * Pipeline Function that adds a {@link MapSequence} transform to the chain.
   * @param {MapSequence~callback} callback - function to call on each element in the sequence
   * @returns {MapSequence}
   */
  Sequence.prototype.map = function(callback) {
    return new MapSequence(this, callback);
  };

  /*
   * Pipeline Function that adds a {@link FilterSequence} transform to the chain.
   * @param {FilterSequence~callback} filterFn - function is a predicate to test each element of the
   * sequence.  Return true to keep the element, false to filter it out.
   * @returns {FilterSequence}
   */
  Sequence.prototype.filter = function(filterFn) {
    return new FilterSequence(this, filterFn);
  };

  /*
   * Terminal Function that iterates the sequence and produces an appropriate value, usually an array
   *
   * @callback Sequence~forEachCallback
   * @param {*} currentValue - Value of the current element being processed in the sequence
   * @returns {Array} Array of values resulting from the sequence transformations
   */
  Sequence.prototype.value = function() {
    var vals = [];

    this.forEach(function(el) {
      vals.push(el);
    });

    return vals;
  };

  /*
   * Terminal Function that applies a function against an accumulator and each element
   * in the sequence to reduce it to a single value.
   * @param {Sequence~reduceCallback} callback - function to call on each element in the sequence
   * @param {*} [initialValue] - Value to use as the first argument to the first call of the callback.
   * If no initial value is supplied, the first element of the sequence will be used.  May be
   * required for certain element types such as GlideRecords or Objects.
   * @returns {*} The value resulting from the reduction
   *
   * @callback Sequence~reduceCallback
   * @param {*} accumulator - The accumulated value returned by the previous callback invocation or
   * initial value if provided
   * @param (*) currentValue - Value of the current element being processed in the sequence
   * @returns {*} Accumulated value to pass to the next invocation of the callback
   */
  Sequence.prototype.reduce = function(callback, initialValue) {
    var accum = initialValue,
      temp;

    if (accum === undefined && this.next()) {
      accum = this.current();
    }

    this.forEach(function(el) {
      accum = callback(accum, el);
    });

    return accum;
  };

  /*
   * Pipeline Function that adds a {@link ChunkSequence} transform to the chain.
   * @param {number} size - Maximum number of elements to include in each {@link ChunkItemSequence}
   * @returns {ChunkSequence}
   */
  Sequence.prototype.chunk = function(size) {
    return new ChunkSequence(this, size);
  };

  /*
   * Collection Sequence that yields GlideRecord rows.  Keep in mind that previous record references
   * are lost with each call of gr.next().  Combining certain transformations may have unexpected results.
   * It is recommended to use a {@link MapSequence} to convert a GlideRecord to a more stable object
   * early in the transformation chain.
   * @constructor
   * @param {GlideRecord|string} table - A table or preprepared GlideRecord object to query
   * @param {string} [query] - Encoded query string to use when a table is provided as the first param
   */
  function GlideRecordSequence(table, query) {
    if (typeof table == 'string') {
      this.gr = new GlideRecord(table);
      this.gr.addEncodedQuery(query);
    }
    else {
      this.gr = table;
    }

    this.gr.query();
  }

  GlideRecordSequence.prototype = Object.create(Sequence.prototype);
  GlideRecordSequence.prototype.constructor = GlideRecordSequence;

  GlideRecordSequence.prototype.next = function() {
    return this.gr.next();
  };

  GlideRecordSequence.prototype.current = function() {
    return this.gr;
  };

  /*
   * Collection Sequence that yields Array values.
   * @constructor
   * @param {Array} arr - An array of values to iterate
   */
  function ArraySequence(arr) {
    this.parent = this;
    this.ix = -1;
    this.arr = arr;
  }

  ArraySequence.prototype = Object.create(Sequence.prototype);
  ArraySequence.prototype.constructor = ArraySequence;

  ArraySequence.prototype.next = function() {
    this.ix++;
    return this.ix < this.arr.length;
  };

  ArraySequence.prototype.current = function() {
    return this.arr[this.ix];
  };

  /*
   * Pipeline Sequence that passes each element of the Sequence to the callback function.
   * @constructor
   * @param {Sequence} parent - The parent sequence to map over
   * @param {MapSequence~callback} callback - function to call on each element in the sequence
   *
   * @callback MapSequence~callback
   * @param {*} currentValue - Value of the current element being processed in the sequence
   * @returns {*} Transformed element to yield next for the {@link MapSequence}
   */
  function MapSequence(parent, callback) {
    this.parent = parent;
    this.ix = -1;
    this.callback = callback;
  }

  MapSequence.prototype = Object.create(Sequence.prototype);
  MapSequence.prototype.constructor = MapSequence;

  MapSequence.prototype.next = function() {
    this.ix++;
    return this.parent.next();
  };

  MapSequence.prototype.current = function() {
    return this.callback(this.parent.current(), this.ix);
  };

  /*
   * Pipeline Sequence that includes all elements from the parent sequence except those
   * that fail the predicate.
   * @constructor
   * @param {Sequence} parent - The parent sequence to map over
   * @param {FilterSequence~callback} callback - function is a predicate to test each element of the
   * sequence.
   *
   * @callback FilterSequence~callback
   * @param {*} currentValue - Value of the current element being processed in the sequence
   * @returns {boolean} Return true to keep the element, false to filter it out.
   */
  function FilterSequence(parent, callback) {
    this.parent = parent;
    this.callback = callback;
    this.el = undefined;
  }

  FilterSequence.prototype = Object.create(Sequence.prototype);
  FilterSequence.prototype.constructor = FilterSequence;

  FilterSequence.prototype.next = function() {
    while (this.parent.next()) {
      this.el = this.parent.current();
      if (this.callback(this.el)) {
        return true;
      }
    }

    return false;
  };

  FilterSequence.prototype.current = function() {
    return this.el;
  };

  /*
   * Pipeline Sequence that breaks a parent sequence into a sequence of {@link ChunkItemSequence}s
   * of a maximum specified size
   * @constructor
   * @param {Sequence} parent - The parent sequence to split up
   * @param {number} size - The maximum number of elements to include in each {@link ChunkItemSequence}.
   * The last chunk may have fewer elements if the total elements is not divisible by the size.
   */
  function ChunkSequence(parent, size) {
    this.parent = parent;
    this.size = size;
  }

  ChunkSequence.prototype = Object.create(Sequence.prototype);
  ChunkSequence.prototype.constructor = ChunkSequence;

  ChunkSequence.prototype.next = function() {
    return this.parent.next();
  };

  ChunkSequence.prototype.current = function() {
    return new ChunkItemSequence(this, this.size);
  };

  ChunkSequence.prototype.value = function() {
    var vals = [];

    this.forEach(function(chunk) {
      vals.push(chunk.value());
    });

    return vals;
  };

  /*
   * Pipeline Sequence that is yielded by a {@link ChunkSequence}.  Represents a chunk of sequence elements.
   * @constructor
   * @param {Sequence} parent - The {@link ChunkSequence} from which the chunk derives it's elements
   * @param {number} size - The maximum number of elements to include in the sequence.
   * The last chunk may have fewer elements if the total elements is not divisible by the size.
   */
  function ChunkItemSequence(parent, size) {
    this.parent = parent;
    this.remaining = size;
    this.first = true;
  }

  ChunkItemSequence.prototype = Object.create(Sequence.prototype);
  ChunkItemSequence.prototype.constructor = ChunkItemSequence;

  ChunkItemSequence.prototype.next = function() {
    if (this.first) {
      this.first = false;
      this.remaining--;
      return true;
    }

    if (this.remaining-- && this.parent.next()) {
      return true;
    }

    return false;
  };

  ChunkItemSequence.prototype.current = function() {
    return this.parent.parent.current();
  };

  /*
   * Wraps an object and returns a {@link Sequence} of an appropriate type for the collection
   * passed in.
   *
   * - For Arrays, Glider will return an {@link ArraySequence}
   * - For GlideRecords, Glider will return a {@link GlideRecordSequence}
   * - For a table / query pair, Glider will return a {@link GlideRecordSequence}
   * - Otherwise, Glider will throw an error
   *
   * @param {array|string|GlideRecord} collection - Collection to wrap or table name to query from
   * @param {string} [query] - Encoded query string to use if a table name was provided in the first param
   * @returns {Sequence} A sequence of the appropriate type
   */
  function CollectionWrapper(col, query) {
    if (Array.isArray(col)) {
      return new ArraySequence(col);
    }
    else if (col.toString() == '[object GlideRecord]' || col.toString() == '[object ScopedGlideRecord]') {
      return new GlideRecordSequence(col);
    }
    else if (typeof col == 'string') {
      return new GlideRecordSequence(col, query);
    }
    else {
      throw 'Collection is not recognized as a GlideRecord or Array';
    }
  }

  return CollectionWrapper;
})();
